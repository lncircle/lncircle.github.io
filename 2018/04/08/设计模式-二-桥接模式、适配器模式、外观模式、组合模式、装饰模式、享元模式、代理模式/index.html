<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>设计模式(二)----桥接模式、适配器模式、外观模式、组合模式、装饰模式、享元模式、代理模式 · lncircle</title><meta name="description" content="桥接模式要实现多个有相同的类的操作，他们又有各自的控制单元，如车控钥匙控制车辆的上锁、解锁。如果每种钥匙都对应每种车辆的话，具体代码会剧增。我们可以将车辆型号和钥匙隔控制逻辑离开来。钥匙的同一操控可以复用和扩展，而不会影响其他电视剧型号。桥接的目标是把抽象层次结构从实现中分离出来，让它能够独立变更。"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">lncircle</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span> ©2018 lncircle</span><span></span></a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>设计模式(二)----桥接模式、适配器模式、外观模式、组合模式、装饰模式、享元模式、代理模式</a></h3></div><div class="post-content"><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>要实现多个有相同的类的操作，他们又有各自的控制单元，如车控钥匙控制车辆的上锁、解锁。如果每种钥匙都对应每种车辆的话，具体代码会剧增。我们可以将车辆型号和钥匙隔控制逻辑离开来。钥匙的同一操控可以复用和扩展，而不会影响其他电视剧型号。桥接的目标是把抽象层次结构从实现中分离出来，让它能够独立变更。</p>
<p>桥接模式类图：<br><img src="/2018/04/08/设计模式-二-桥接模式、适配器模式、外观模式、组合模式、装饰模式、享元模式、代理模式/桥接模式类图.png" alt="avatar"></p>
<p>图中我们可以通过UniversalApp来实现对MoBike和OFOBike的控制操作，他们通过各自的抽象类进行桥接在一起，实现控制与实现的分离。</p>
<p>UniversalApp模型的实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)lock</span><br><span class="line">&#123;</span><br><span class="line">    [self sendCommand:Command_lock];</span><br><span class="line">&#125;</span><br><span class="line">- (void)open</span><br><span class="line">&#123;</span><br><span class="line">    [self sendCommand:Command_open];</span><br><span class="line">&#125;</span><br><span class="line">- (void)broken</span><br><span class="line">&#123;</span><br><span class="line">    [self sendCommand:Command_broken];</span><br><span class="line">&#125;</span><br><span class="line">- (void)reserve</span><br><span class="line">&#123;</span><br><span class="line">    [self sendCommand:Command_reserve];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>App模型的实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendCommand:(Command)<span class="built_in">command</span></span><br><span class="line">&#123;</span><br><span class="line">    [self.bike receiveCommand:<span class="built_in">command</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本节<a href="https://github.com/lncircle/Proxy-pattern/tree/master/Bridge-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">工程示例</a></p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>在一些应用中，我们创建的类已经拥有的一定的行为，而我们客户端需要拥有自己定义的行为，我们就可以使用适配器模式，将原有的行为传递给使用者。例如像我们大陆去香港购物，香港当地是用港币结算，但在大陆习惯用人民币来衡量物品的价值，这时候的思维往往会用港币转换成人民币来计算，这时我们就可以用适配器模式来适配港币的结算来获得人民币的价值。实现适配器模式有两种方式，已是通过继承适配者，调用父类方法来适配，也称为类适配。另一种是通过组合方式，持有适配对象，来实现适配功能。</p>
<p>类适配器模式类图<br><img src="/2018/04/08/设计模式-二-桥接模式、适配器模式、外观模式、组合模式、装饰模式、享元模式、代理模式/类适配器模式类图.png" alt="avatar"></p>
<p>适配功能在Adapter_Class的实现中进行，调用父类的方法，进行操作。</p>
<p>Adapter_Class的实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">float</span> rate = 0.82;</span><br><span class="line"></span><br><span class="line">@implementation Adapter_Class</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">float</span>)getSellPriceUseCNY</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> [super getSellPriceUseHKD] * rate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>对象适配器模式类图<br><img src="/2018/04/08/设计模式-二-桥接模式、适配器模式、外观模式、组合模式、装饰模式、享元模式、代理模式/对象适配器模式类图.png" alt="avatar"><br>Adapter_Object的实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">float</span> rate_o = 0.82;</span><br><span class="line"></span><br><span class="line">@implementation Adapter_Object</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</span><br><span class="line">        _goods = [[HKGoods alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">float</span>)getSellPriceUseCNY</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> [self.goods getSellPriceUseHKD] * rate_o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>本节<a href="https://github.com/lncircle/Proxy-pattern/tree/master/Adapter-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">工程示例</a></p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>在一些子系统逐渐复杂的应用场景中，我们可以将一组不同的接口提供统一接口。定义上层接口，通过降低复杂度和隐藏子系统间的通信及依存关系，让子系统更易于使用。例如在使用XMPP协议的登录过程，我们在登录的时候分好几个步骤，同时UI也会跟随着登录状态进行相应的变化，我们可以统一成一个登录接口，供客户端调用。使用这种方式让子系统更容易使用的方式就是外观模式。</p>
<p>外观模式类图：</p>
<p><img src="/2018/04/08/设计模式-二-桥接模式、适配器模式、外观模式、组合模式、装饰模式、享元模式、代理模式/外观模式类图.png" alt="avantar"></p>
<p>客户端要实现登录功能，只需调用LoginManager的loginAction方法即可完成UI变化和XMPP登录的一整套流程，简化了登录的调用。<br>其中登录接口的实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)loginAction</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    XMPPLogin *login = [[XMPPLogin alloc] init];</span><br><span class="line">    UIStatue *ui = [[UIStatue alloc] init];</span><br><span class="line">    </span><br><span class="line">    [ui logining];</span><br><span class="line">    [login connetXMMPServer];</span><br><span class="line">    [login authenticationPassWord];</span><br><span class="line">    [login xmppDidAuthenticate];</span><br><span class="line">    [ui logined];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本节<a href="https://github.com/lncircle/Proxy-pattern/tree/master/Exterior-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">工程示例</a></p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>把一些相同基类型的对象组合到树状结构中，父节点包含同类型的子节点，像平时公司的组织架构、家族结构、公司同一系列产品都可以使用这种模式。拿公司组织架构来说，公司包含多个部门，部门又包含多个员工。我们可以通过统一的接口把这整个复杂结构作为一个整体来使用，如通知公司放假、公司传达到各个部门，各个部门再通知下面的员工。其实也就是将对象组合成“部分-整体”的关系，让其中的每个节点具有相同的抽象接口。</p>
<p>组合模式类图：</p>
<p><img src="/2018/04/08/设计模式-二-桥接模式、适配器模式、外观模式、组合模式、装饰模式、享元模式、代理模式/组合模式类图.png" alt="avantar"></p>
<p>MemberModel定义了统一的接口,它的操作可以通过递归传达到借点的每一处。</p>
<p>其中Company的实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)addMember:(id &lt;MemberModel&gt;)member</span><br><span class="line">&#123;</span><br><span class="line">    [self.childMembers addObject:member];</span><br><span class="line">&#125;</span><br><span class="line">- (void)removeMember:(id &lt;MemberModel&gt;)member</span><br><span class="line">&#123;</span><br><span class="line">    [self.childMembers removeObject:member];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</span><br><span class="line">        _childMembers = [NSMutableArray&lt;MemberModel&gt; array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本节<a href="https://github.com/lncircle/Proxy-pattern/tree/master/Composite-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">工程示例</a></p>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>有些时候我们需要对现有的行为进行一定的修饰，又希望不改变原有的功能，我们就可以使用装饰模式，也是动态的给一个对象添加一些扩展功能。例如就跑步来说，最开始只有跑步的功能，现在在不需要改变原有的功能上，给它加点快跑和慢跑的修饰。我们抽象一个父类，细化另一个抽象类，这个抽象类包含了父类中的一个引用，具体的修饰行为交给他的子类来表示。</p>
<p>装饰模式类图：</p>
<p><img src="/2018/04/08/设计模式-二-桥接模式、适配器模式、外观模式、组合模式、装饰模式、享元模式、代理模式/装饰模式类图.png" alt="avantar"></p>
<p>MemberModel定义了统一的接口,它的操作可以通过递归传达到借点的每一处。</p>
<p>其中RunDecorator的实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithRun:(id&lt;RunProtocol&gt;)runer</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    <span class="keyword">if</span> (self) &#123;</span><br><span class="line">        _runer = runer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了以上的这种装饰方式外，在OC中还可以使用类别来进行装饰，它装饰饰的方式是编译时绑定的，而且它成为了类的一部分。但在一些简单装饰的话，可以用类别来实现，使用起来更为简洁方便。</p>
<p>本节<a href="https://github.com/lncircle/Proxy-pattern/tree/master/Decorator-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">工程示例</a></p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>在应用程序要使用很多对象，我们可以共享这些对象的一些共同点，以节省内存空间。就像奥运会一样，每一场比赛都需要比赛场地，我们不可能每场比赛都使用新的场馆，现实没那么多的场地资源支撑，同一类型的比赛使用同一场地，这样可以节省很多资源。就像我们需要某种资源了，看看是否已经拥有，有的话就直接使用，没有再创建，也就是共享可用对象。</p>
<p>享元模式类图：</p>
<p><img src="/2018/04/08/设计模式-二-桥接模式、适配器模式、外观模式、组合模式、装饰模式、享元模式、代理模式/享元模式类图.png" alt="avantar"></p>
<p>PlaygroudFactory定义工厂方法,它利用缓存池来保证对象的共享使用。</p>
<p>其中PlaygroudFactory的实现部分</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (id&lt;Playground&gt;)playgroudWithStation:(PlaygroudStation)station</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.playgroudPools == nil) &#123;</span><br><span class="line">        self.playgroudPools = [[NSMutableDictionary alloc] initWithCapacity:kTotalNumberPlaygroud];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BJPlaygroud *playgroud = [self.playgroudPools objectForKey:[NSNumber numberWithInteger:station]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (playgroud == nil) &#123;</span><br><span class="line">        </span><br><span class="line">        playgroud = [[BJPlaygroud alloc] init];</span><br><span class="line">        </span><br><span class="line">        switch (station) &#123;</span><br><span class="line">            <span class="keyword">case</span> kPlaygroud_NationalStadium:</span><br><span class="line">                playgroud.name = @<span class="string">"国家体育场"</span>;</span><br><span class="line">                playgroud.events = @<span class="string">"田径、足球"</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> kPlaygroud_NationalAquaticsCenter:</span><br><span class="line">                playgroud.name = @<span class="string">"国家游泳中心"</span>;</span><br><span class="line">                playgroud.events = @<span class="string">"游泳"</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> kPlaygroud_NationalIndoorStadium:</span><br><span class="line">                playgroud.name = @<span class="string">"国家体育馆"</span>;</span><br><span class="line">                playgroud.events = @<span class="string">"体操、蹦床、手球"</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kPlaygroud_ShootingRangeHall:</span><br><span class="line">                playgroud.name = @<span class="string">"北京射击馆"</span>;</span><br><span class="line">                playgroud.events = @<span class="string">"射击"</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">                </span><br><span class="line">            default:</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [self.playgroudPools setObject:playgroud forKey:[NSNumber numberWithInt:station]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> playgroud;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本节<a href="https://github.com/lncircle/Proxy-pattern/tree/master/Flyweight-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">工程示例</a></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为其他对象提供一种代理以控制对这个对象的访问。例如我要购买火车票，如果需要跑到车站去买的话，会花很多时间，这个时候我就可以找个附近的代售点进行购买。除了像这种情况，还可以创建重型对象，来延迟加载和调用，根据不同的访问权限控制对原对象的访问也可以使用这种方式。</p>
<p>代理模式类图：</p>
<p><img src="/2018/04/08/设计模式-二-桥接模式、适配器模式、外观模式、组合模式、装饰模式、享元模式、代理模式/代理模式类图.png" alt="avantar"></p>
<p>客户端要进行买票操作的时候，通过代理对象调用上层抽象接口，来实现实际售票对象的卖票功能，其中CommissionMerchant的实现部分</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    <span class="keyword">if</span> (self) &#123;</span><br><span class="line">        _station = [[Station alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sellTicket</span><br><span class="line">&#123;</span><br><span class="line">    [self.station sellTicket];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本节<a href="https://github.com/lncircle/Proxy-pattern/tree/master/Proxy-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">工程示例</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-04-08</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2018/04/08/设计模式-二-桥接模式、适配器模式、外观模式、组合模式、装饰模式、享元模式、代理模式/,lncircle,设计模式(二)----桥接模式、适配器模式、外观模式、组合模式、装饰模式、享元模式、代理模式,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/04/15/设计模式-三-中介者模式、观察者模式、访问者模式、策略模式、责任链模式/" title="设计模式(三)----中介者模式、观察者模式、访问者模式、策略模式、责任链模式">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/04/06/设计模式-一-原型模式、工厂模式、抽象工厂模式、建造者模式、单例模式/" title="设计模式(一)----原型模式、工厂模式、抽象工厂模式、建造者模式、单例模式">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>